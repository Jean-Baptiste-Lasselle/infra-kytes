#!/bin/bash

# - > à exécuter depusi un poste debian, sur lequel git est installé, ainsi que SSH

export MAISON_OPS=.
# 
# - 
# export USER_LX_OPERATEUR_SERVEUR_DISTANT=jibl
# export NOM_HOTE_RESEAU_SERVEUR_DISTANT=production-docker-host-1.kytes.io
# - 
# 
# Je veux créer le répertoire surlequel je vais monter le disque dur externe:
# Ce répertoire sera différent à chaque backup, il ne sera jamais le même, par sécurité.
export CHEMIN_MONTAGE_DISQUE_DUR_EXTERNE_DRP=/media/jbl/disque/dur/externe/pour/bckups/kytes-bckup-storage-$HORODATAGE_OPS
export CHEMIN_MAISON_KYTES_DRP=$CHEMIN_MONTAGE_DISQUE_DUR_EXTERNE_DRP/kytes-production-drp
# export REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR=/infra-kytes
export CHEMIN_LIEN_SYMBOLIQUE_BCKUP_DS_SERVEUR=./most_recent_backup.zip

cd $MAISON_OPS


export UUID_DE_MON_DISQUE_DUR_EXTERNE=70BE639EBE635B9A

export UUID_DE_MON_DISQUE_DUR_EXTERNE=$(sudo blkid|grep Seagate|awk '{print $5}'|awk -F '"' '{print $2}')
echo "   "
echo "   VERIF_UUID_DISQUE_DUR_EXTERNE : UUID_DE_MON_DISQUE_DUR_EXTERNE=$UUID_DE_MON_DISQUE_DUR_EXTERNE"
echo "   "
echo "   VERIF USER_LX_OPERATEUR_SERVEUR_DISTANT=$USER_LX_OPERATEUR_SERVEUR_DISTANT"
echo "   VERIF NOM_HOTE_RESEAU_SERVEUR_DISTANT=$NOM_HOTE_RESEAU_SERVEUR_DISTANT"
echo "   VERIF REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR=$REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR"
echo "   "

echo " Pressez entrée pour continuer  "
read VERIF_UUID_DISQUE_DUR_EXTERNE
# redhat grown ...
if [ "UUID_DE_MON_DISQUE_DUR_EXTERNE" == "x$UUID_DE_MON_DISQUE_DUR_EXTERNE" ]; then
  echo "La procédure de backup ne trouve pas le disque dur externe Seagate: Est-il bien branché? "
  echo "Procédez aux vérifications, puis relancez ce script"
  exit 1
fi


cd exploitation

echo " -------------------------------------- "
echo "  Déconnectez, puis reconnectez, le     "
echo "  disque dur externe. "
echo "  (Cela relancera la palpation Linux).  "
echo " -------------------------------------- "
echo "  Pressez ensuite Entrée.  "
echo " -------------------------------------- "
read DEBRACNHER_REBRANCHER_MAXTOR

chmod +x ./monter-disque-dur-externe.sh


# 
# Ce script prend TOUJOURS deux arguements, dans cet ordre :
# $1 => le UUID du disque de backup à monter
# $2 => le chemin du répertoire, point de montage du disque de backup.
# $3 => le type de filesystem : `ext3`, `ext4`, `ntfs-3g` (pour le diques dur externe qui ont été formatés en NTFS) / etc...
# 
./monter-disque-dur-externe.sh $UUID_DE_MON_DISQUE_DUR_EXTERNE $CHEMIN_MONTAGE_DISQUE_DUR_EXTERNE_DRP ntfs-3g

echo "   Maintenant, le disque dur externe devrait être monté sur CHEMIN_MONTAGE_DISQUE_DUR_EXTERNE_DRP=$CHEMIN_MONTAGE_DISQUE_DUR_EXTERNE_DRP "
echo " "
echo " Vérif du cotenu : "
echo " -------------------------------------- "
ls -all $CHEMIN_MONTAGE_DISQUE_DUR_EXTERNE_DRP
echo " -------------------------------------- "
echo " "
echo " Pressez entrée pour continuer  "
read VERIF_MONTAGE_DISQUE_DUR_EXTERNE



clear
echo " -------------------------------------- "
echo "   Maintenant, ouvrez une session shell "
echo "   en paralèlle de celle-ci, et connectez-vous"
echo "   en ssh au serveur cible, avec l'instruction : "
echo "    [ssh -i ~/.ssh/id_rsa jibl@production-docker-host-1.kytes.io]   "
echo "   Exécutez-y les instrcutions suivantes pour lancer le backup : "
echo "    [cd $REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR && chmod +x exploitation/backup.sh && exploitation/backup.sh] "
echo " -------------------------------------- "
echo "   Lorsquele backup est terminé, Pressez la touche entrée, pour terminer, et sctocker le backup  sur le disque dur externe. "
echo " -------------------------------------- "
read ATTENTE_BCKUP
# j'exécute à disquance le script backup : il a été installé au git clone lors de la provision / restauration la plus récente de 'll=infrastructure.
# ssh -i ~/.ssh/id_rsa jibl@production-docker-host-1.kytes.io -C "cd $REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR && chmod +x exploitation/backup.sh"
# ssh -i ~/.ssh/id_rsa jibl@production-docker-host-1.kytes.io -C "export CHEMIN_LIEN_SYMBOLIQUE_BCKUP_DS_SERVEUR=$CHEMIN_LIEN_SYMBOLIQUE_BCKUP_DS_SERVEUR && cd $REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR && exploitation/backup.sh"
# je récupère le ZIP produit

# echo " OK, TODO : il faut farie evoluer l'ensemble del a procédure de backup : pourquoi pas utiliser un lien symboliquedans exploitation/backup.sh, ' ln -s $NOM_FICHIER_ZIP_PRODUIT_QUI_CONTIENT_DATE_IMPREVISISBLE    $REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR/most_recent_backup.zip '  "
# exit 1

echo " -------------------------------------- "
echo "  Dernière étape: onrécupère le backup  "
echo "  pour le stocker sur disque dur externe "
echo " -------------------------------------- "

# Avant de déterminer quel est le nom du fichier backup, Localement, on
# supprime le fichier '$HOME/infra-kytes/exploitation/canttouchthis.kytes', s'il existe
if [  -f canttouchthis.kytes ]; then rm -f canttouchthis.kytes; echo "removed previous [./canttouchthis.kytes] file "; fi;
# De même, Sur le serveur distant, on supprime le fichier '$HOME/infra-kytes/exploitation/canttouchthis.kytes', s'il existe
ssh -i ~/.ssh/id_rsa jibl@production-docker-host-1.kytes.io -C "if [  -f $REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR/canttouchthis.kytes ]; then rm -f $REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR/canttouchthis.kytes; echo \"removed previous [REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR/canttouchthis.kytes] file \" >> canttouchthis.kytes.log; fi;"
# Puis on détermine rle nom du fichier de backup le plus récent, grâce au lien symbolique [$CHEMIN_LIEN_SYMBOLIQUE_BCKUP_DS_SERVEUR]
ssh -i ~/.ssh/id_rsa jibl@production-docker-host-1.kytes.io -C "ls -all $REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR|grep monbckupleplusrecent.zip |awk '{print \$11}'  >> $REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR/canttouchthis.kytes"
scp -i ~/.ssh/id_rsa jibl@production-docker-host-1.kytes.io:$REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR/canttouchthis.kytes .
cat canttouchthis.kytes >> canttouchthis.kytes.log
export NOM_FICHIER_ZIP_PRODUIT=$(cat canttouchthis.kytes) 
# exemple : ./kytes-bckup-2018-10-27day_21h-09min-00sec.zip
scp -i ~/.ssh/id_rsa $USER_LX_OPERATEUR_SERVEUR_DISTANT@$NOM_HOTE_RESEAU_SERVEUR_DISTANT:$REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR/$NOM_FICHIER_ZIP_PRODUIT ./$NOM_FICHIER_ZIP_PRODUIT
scp -i ~/.ssh/id_rsa $USER_LX_OPERATEUR_SERVEUR_DISTANT@$NOM_HOTE_RESEAU_SERVEUR_DISTANT:$REPERTOIRE_EXPLOITATION_KYTES_DANS_SERVEUR/$NOM_FICHIER_ZIP_PRODUIT.sha512sum ./$NOM_FICHIER_ZIP_PRODUIT.sha512sum

# -> vérification chaînée de l'intégrité, sinon lopération échoue
zip -T ./$NOM_FICHIER_ZIP_PRODUIT >> ./$NOM_FICHIER_ZIP_PRODUIT.integrity.live || exit 1

# Et il ne reste plus qu'à copier le zip obtenu dans le stockage physiquement distinct: backup restore de type (1,2)
clear
echo "  "
echo "Je suis $(whoami), et je backup l'infra kytes vers le répetoire  : "
echo " [$CHEMIN_MAISON_KYTES_DRP] "
echo "  "
cp -f $NOM_FICHIER_ZIP_PRODUIT $CHEMIN_MAISON_KYTES_DRP
cp -rf $NOM_FICHIER_ZIP_PRODUIT.sha512sum $CHEMIN_MAISON_KYTES_DRP/$NOM_FICHIER_ZIP_PRODUIT.sha512sum

cd $CHEMIN_MAISON_KYTES_DRP
zip -T $NOM_FICHIER_ZIP_PRODUIT >> $NOM_FICHIER_ZIP_PRODUIT.integrity
echo " "
echo " Le fichier de backup copiéest-il intègre? "
echo " "
cat $NOM_FICHIER_ZIP_PRODUIT.integrity
echo " "
sha512sum -c $NOM_FICHIER_ZIP_PRODUIT.sha512sum
echo " "
echo " DIY => (zip -T $NOM_FICHIER_ZIP_PRODUIT) "
echo " "
ls -all
